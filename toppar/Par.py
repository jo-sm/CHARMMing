#!/usr/bin/env python
# fcp v0.1 01/11/2010

import copy

def get_section_title(iterator):
    """Takes an iterator containing a blob of charmm text, and separates the first line containing
    the charmm from the rest of the blob.  This accounts for pesky line continuations: '-' ."""
    buffer = [ iterator[0] ]
    check_me = [ line.split('!')[0].lstrip().upper() for line in iterator ]
    for i,line in enumerate(check_me):
        if line.rstrip().endswith('-'):
            buffer.append(iterator[i+1])
        else:
            break
    return (buffer,iterator[i+1:])

class Par(dict):
    """.
    """
    def __init__(self,iterator,name=''):
        """Constructor"""
        self.name       = name
        self.text       = [ line.lstrip() for line in iterator if ( not line.lstrip().startswith('!') and line.strip() ) ]
        self.check_me   = [ line.split('!')[0].lstrip().upper() for line in self.text ]
        # Initialize
        dict.__init__( self, self.split() )     # Build dict
        self.header     = self['header']        # Delete extraneous sections
        del self['header']
        try:    # Mass information is stored in the .rtf file, this is redundant
            del self['ATOM']
        except KeyError: pass
        self.charmm_header  = self.set_charmm_header()
        del self.header
        # Split section titles off of of each section
        self.title = {}
        for key in self:
            (self.title[key],self[key]) = get_section_title( self[key] )

    def split(self):
        """bleh"""
        keys    = []
        values  = []
        parsing_header  = True
        section_buffer  = []
        first_line      = 'header'
        for i,line in enumerate(self.check_me):
            section_buffer.append(self.text[i])
            if line.startswith('ATOM') or line.startswith('BOND') or line.startswith('ANGL') or line.startswith('DIHE')\
                    or line.startswith('IMPR') or line.startswith('CMAP') or line.startswith('NONB') or line.startswith('NBFI')\
                    or line.startswith('HBON') or line.startswith('END'):
                if parsing_header:
                    parsing_header = False
                    keys.append('header')
                else:
                    keys.append(first_line.split()[0][:4])
                values.append( [first_line] + section_buffer[:-1] )
                first_line      = line
                section_buffer  = []
        return zip(keys,values)

    def set_charmm_header(self):
        """Return all lines that start with '*' __and__ have other text in them.
        The terminal header line is skipped!"""
        return [ line for line in self.header if ( line.startswith('*') and len( line.split() ) > 1 ) ]

    def unique(self):
        """Remove all redundant parameter definitions, and return a Par file with unique definitions."""
        new_par = copy.deepcopy(self)

        def unique_section(string,begin,end,delete=None):
            try:
                unique = {}
                for line in new_par[string]:
                    key = line.split()[begin:end]
                    if delete:
                        del key[delete]
                    unique[ tuple(key) ] = line
                new_par[string] = [ unique[key] for key in unique ]
    
                n_dupes = len(self[string]) - len(new_par[string])
                if n_dupes:
                    print "unique_section: %i duplicate entries were found and removed in the %s section" % (n_dupes,string)
            except KeyError:
                print "unique_section: Can't find %s section in .prm file, skipping..." % string

        unique_section('BOND',0,2)
        unique_section('ANGL',0,3)
        unique_section('DIHE',0,6,4)
        unique_section('IMPR',0,6,4)
#       unique_section('CMAP',0,8)      # Untested
        unique_section('NONB',0,1)
        unique_section('NBFI',0,2)
        unique_section('HBON',0,2)

        new_par.text = new_par.Print()
        new_par.check_me = [ line.split('!')[0].lstrip().upper() for line in new_par.text ]
        return new_par

    def merge(self,*args):
        """Merges two or more Par files together.  Section titles are only retained from the original
        Par file that is merged (ie. self)."""
        for arg in args:
            assert type(arg) == Par
        new_par = copy.deepcopy(self)
        # Charmm header
        new_par.charmm_header = ['* This .prm file was generated by CHARMMING, the original headers follow:\n']
        new_par.charmm_header += ['* name: %s\n' % self.name]
        new_par.charmm_header += self.charmm_header
        for arg in args:
            new_par.charmm_header += ['* name: %s\n' % arg.name]
            new_par.charmm_header += arg.charmm_header
        
        def merge_section(string):
            try:
                for i,arg in enumerate(args):
                    new_par[string] += arg[string]
            except KeyError:
#               print "merge_section: Can't find %s section in args[%i], aborting..." % (string,i)
#               raise AssertionError
                print "merge_section: Can't find %s section in .prm file, skipping..." % string
            return

        try:        # If it can't merge a section we want it to die painfully
            merge_section('BOND')
            merge_section('ANGL')
            merge_section('DIHE')
            merge_section('IMPR')
#           merge_section('CMAP')       # Untested
            merge_section('NONB')
            merge_section('NBFI')
            merge_section('HBON')
        except AssertionError:
            return
        else:
            new_par.text = new_par.Print()
            new_par.check_me = [ line.split('!')[0].lstrip().upper() for line in new_par.text ]
            return new_par

    def cull(self,atom_sets):
        """Takes an atom_set generated by Top.get_atom_set() and prunes extraneous parameters for each
        section of the .prm file."""
        new_par = copy.deepcopy(self)

        def cull_section(string,begin,end):
            try:
                buffer = []
                for line in new_par[string]:
                    check_set = set( line.split()[begin:end] )
                    good_line = False
                    for res in atom_sets:
                        if check_set.issubset(atom_sets[res]):
                            good_line = True
                            break
                    if good_line:
                        buffer.append(line)
                new_par[string] = buffer
            except KeyError:
                print "cull_section: Can't find %s section in .prm file, skipping..." % string
            return
                    # If it can't cull a section we don't really care
        cull_section('BOND',0,2)
        cull_section('ANGL',0,3)
        cull_section('DIHE',0,4)
        cull_section('IMPR',0,4)
#       cull_section('CMAP',0,8)        # Untested
        cull_section('NONB',0,1)
        cull_section('NBFI',0,1)
        # Exclude 'HBON' section

        new_par.text = new_par.Print()
        new_par.check_me = [ line.split('!')[0].lstrip().upper() for line in new_par.text ]
        return new_par

    def Print(self):
        """Returns a list of strings that can be fed to a file handle to write a .prm file."""
        print_me = []

        for line in self.charmm_header:
            print_me.append(line)
        print_me.append('*')
        print_me.append('\n')

        def print_section(string):
            try:
                for line in self.title[string]:
                    print_me.append(line)
                for line in self[string]:
                    print_me.append(line)
                print_me.append('\n')
            except KeyError:
                print "print_section: Can't find %s section in .prm file, skipping..." % string
            return

        print_section('BOND')
        print_section('ANGL')
        print_section('DIHE')
        print_section('IMPR')
        print_section('CMAP')
        print_section('NONB')
        print_section('NBFI')
        print_section('HBON')
        print_me.append('END')

        return print_me
