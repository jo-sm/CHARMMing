********>Bugfix 29:
Author: Andreas W Goetz
Date: 16 November 2012

Program: SQM SQMlib

Description: Fix error in two-electron integral calculation

This bugfix affects all NDDO based QM calculations with
atoms that are separated by 10 Angstrom or more. It solves SCF
convergence problems with SQM as well as sander QM/MM MD simulations.

-----------------------------------------------------------------------------
 AmberTools/src/sqm/qm2_hcore_qmqm.F90 |   24 ++++++++++++------------
 1 files changed, 12 insertions(+), 12 deletions(-)

diff --git AmberTools/src/sqm/qm2_hcore_qmqm.F90 AmberTools/src/sqm/qm2_hcore_qmqm.F90
index 598d402..2d3a172 100644
--- AmberTools/src/sqm/qm2_hcore_qmqm.F90
+++ AmberTools/src/sqm/qm2_hcore_qmqm.F90
@@ -44,7 +44,7 @@ subroutine qm2_hcore_qmqm(COORD,H,W,ENUCLR)
       integer:: i, j, k, ni, i1, i2
       integer:: kr, j1, first_sj, last_pj, ii, j2, jj, ki
       integer:: loop_count, jstart, jend
-      integer:: n_atomic_orbi, n_atomic_orbj, qmitype, qmjtype
+      integer:: naoi, naoj, qmitype, qmjtype
       _REAL_:: enuc, elec_ke_p
       _REAL_:: half_num, r2, r2InAu, rij, rijInAu, oneOverRij
       _REAL_, allocatable :: WW(:,:)
@@ -101,7 +101,7 @@ subroutine qm2_hcore_qmqm(COORD,H,W,ENUCLR)
  
          firstIndexAO_i=qm2_params%orb_loc(1,I)
          lastIndexAO_i=qm2_params%orb_loc(2,I)                
-         n_atomic_orbi = qm2_params%natomic_orbs(i)
+         naoi = qm2_params%natomic_orbs(i)
          qmitype = qmmm_struct%qm_atom_type(i) 
          NI=qmmm_struct%iqm_atomic_numbers(I)
 !   FILL THE ATOM-OTHER ATOM ONE-ELECTRON MATRIX<PSI(LAMBDA)|PSI(SIGMA)>        
@@ -110,8 +110,11 @@ subroutine qm2_hcore_qmqm(COORD,H,W,ENUCLR)
             
             firstIndexAO_j=qm2_params%orb_loc(1,J)
             lastIndexAO_j=qm2_params%orb_loc(2,J) 
+            naoj = qm2_params%natomic_orbs(j)
             qmjtype = qmmm_struct%qm_atom_type(j)             
             
+            hasDOrbital=((naoi.ge.9) .or. (naoj.ge.9)) 
+
             r2=sum( (coord(1:3,i) - coord(1:3,j)) **2) 
             rij=sqrt(r2)
             rijInAu=rij*A_TO_BOHRS
@@ -125,14 +128,13 @@ subroutine qm2_hcore_qmqm(COORD,H,W,ENUCLR)
             !Fill SHMAT with a 4x4 array of overlaps, in order S,PX,PY,PZ
             !     r2InAu   =  INTERATOMIC DISTANCE^2 IN BOHRS2
 
-                n_atomic_orbj = qm2_params%natomic_orbs(j)
                 
-                if ((n_atomic_orbi.lt.9) .and. (n_atomic_orbj.lt.9)) then
+                if (.not. hasDOrbital) then
                   ! the implementation for sp orbitals by Ross Walker 
                   
                   SHMAT=0.0d0
                   call qm2_h1elec(r2InAu,COORD(1:3,I),COORD(1:3,J),  &
-                            n_atomic_orbi,n_atomic_orbj,SHMAT, qmitype, qmjtype)
+                            naoi,naoj,SHMAT, qmitype, qmjtype)
                   I2=0
                   do I1=firstIndexAO_i,lastIndexAO_i
                      II=qm2_params%pascal_tri1(i1)+firstIndexAO_j-1
@@ -153,12 +155,11 @@ subroutine qm2_hcore_qmqm(COORD,H,W,ENUCLR)
                   ! basically by coping things from the MNDO program  
                   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                   call qm2_h1elec_d(r2InAu,COORD(1:3,I),COORD(1:3,J),  &
-                            n_atomic_orbi,n_atomic_orbj,firstIndexAO_i, firstIndexAO_j,  &
+                            naoi,naoj,firstIndexAO_i, firstIndexAO_j,  &
                             qmitype, qmjtype,qm2_struct%norbs,H)                
                 
                 endif
               
-              
             end if !(R2 < OVERLAP_CUTOFF)
             
             
@@ -169,7 +170,6 @@ subroutine qm2_hcore_qmqm(COORD,H,W,ENUCLR)
             ! -----------------------------------------------------             
             RI=0.0D0
             core=0.0D0
-            hasDOrbital=((n_atomic_orbi.ge.9) .or. (n_atomic_orbj.ge.9)) 
             call GetRotationMatrix(coord(1:3,j)-coord(1:3,i), rotationMatrix, hasDOrbital)   
             
             call qm2_rotate_qmqm(loop_count,i,j,NI,qmmm_struct%iqm_atomic_numbers(J),COORD(1,I),COORD(1,J), &
@@ -188,8 +188,8 @@ subroutine qm2_hcore_qmqm(COORD,H,W,ENUCLR)
               ! Taisung Lee, Rutgers 2011
               !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   
                 
-                i_dimension=qm2_params%natomic_orbs(i)*(qm2_params%natomic_orbs(i)+1)/2
-                j_dimension=qm2_params%natomic_orbs(j)*(qm2_params%natomic_orbs(j)+1)/2
+                i_dimension=naoi*(naoi+1)/2
+                j_dimension=naoj*(naoj+1)/2
                 ki=i_dimension*j_dimension                    
                
                 allocate(ww(1:j_dimension, 1:i_dimension)) 
@@ -212,13 +212,13 @@ subroutine qm2_hcore_qmqm(COORD,H,W,ENUCLR)
                 deallocate(ww)
                 call Rotate2Center2Electron(W(kr), i_dimension,j_dimension, rotationMatrix)
                 
-            end if  ! ((n_atomic_orbi.ge.9) .or. (n_atomic_orbj.ge.9))
+            end if  ! ((naoi.ge.9) .or. (naoj.ge.9))
 
             ii=qm2_params%pascal_tri2(firstIndexAO_i)
             jj=qm2_params%pascal_tri2(firstIndexAO_j)  
                           
             call RotateCore(firstIndexAO_i,firstIndexAO_j,              &
-                qm2_params%natomic_orbs(i),qm2_params%natomic_orbs(j),  &
+                naoi,naoj,  &
                 ii,jj,core,rotationMatrix,H)
 
             call qm2_core_core_repulsion(i, j, rij, oneOverRij, RI(1), enuc)    
