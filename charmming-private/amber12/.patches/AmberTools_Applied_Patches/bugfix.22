********>bugfix.22

Date: Aug. 27, 2012

Author: Jason Swails

Programs: patch_amber.py

Description: This patch fixes patch_amber.py's ability to handle zipped patches,
             and corrects the permissions of files generated by the patching process.
             This patch is necessary for the new Amber12 CUDA upgrade.

------------------------------------------------------------------------------

 patch_amber.py |   70 +++++++++++++++++++++++++++++++++++++++++++-------------
 1 file changed, 54 insertions(+), 16 deletions(-)

diff --git patch_amber.py patch_amber.py
index 84d90c4..2b5ae7a 100755
--- patch_amber.py
+++ patch_amber.py
@@ -25,7 +25,7 @@ Acknowledgements/Contributions from others
    * Tyler Luchko made helpful contributions to the user-interface
 """
 # Load common os module and package into top level namespace
-from os import path, getenv
+from os import path, getenv, chmod
 
 # Global variables. Other ones that change less frequently can be found below
 # the Patch class definitions.
@@ -230,9 +230,11 @@ class Patch(object):
       """
       # This regex matches lines that start like "+++ path/to/file.cpp"
       modfile = re.compile(r'\+\+\+ \.*\/*[\w\-\/\.\+]+[\w\-\.\+]+\.*\w*')
-      selffile = re.compile('\\+\\+\\+ %s' % path.split(sys.argv[0])[1])
+      selffile = re.compile(r'\+\+\+ %s' % path.split(sys.argv[0])[1])
+      newfile = re.compile(r'new file mode (\d{3})+')
       patch = open(self.name, 'r')
       files_modified = []
+      newfile_modes = []
       for line in patch:
          if modfile.match(line):
             filename = modfile.findall(line)[0].strip('+++').strip()
@@ -247,8 +249,17 @@ class Patch(object):
          elif selffile.match(line):
             filename = path.split(sys.argv[0])[1]
             if not filename in files_modified: files_modified.append(filename)
+         elif newfile.match(line):
+            ftmp = newfile.match(line).groups()
+            if isinstance(ftmp, tuple):
+               if len(ftmp) == 2:
+                  newfile_modes.append(ftmp[1])
+               elif len(ftmp) == 1:
+                  newfile_modes.append(ftmp[0])
+            elif isinstance(ftmp, str):
+               newfile_modes.append(ftmp)
       patch.close()
-      return files_modified
+      return files_modified, newfile_modes
 
    #========================================
 
@@ -331,7 +342,7 @@ class PatchBz2(Patch):
       
       print 'Decompressing %s with %s' % (patch_file, bunzip)
 
-      process = Popen([bunzip, patch_file], stdout=PIPE, stderr=PIPE)
+      process = Popen([bunzip, '-f', patch_file], stdout=PIPE, stderr=PIPE)
 
       (output, error) = process.communicate('')
 
@@ -340,8 +351,8 @@ class PatchBz2(Patch):
                           patch_file, error))
          sys.exit(1)
 
-      # Get rid of the file extension
-      patch_file = patch_file.strip('.bz2')
+      # Get rid of the file extension (.bz2)
+      patch_file = patch_file[:len(patch_file)-4]
       Patch.__init__(self, patch_file)
 
 #~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~
@@ -370,7 +381,7 @@ class PatchGz(Patch):
       
       print 'Decompressing %s with %s' % (patch_file, gunzip)
 
-      process = Popen([gunzip, patch_file], stdout=PIPE, stderr=PIPE)
+      process = Popen([gunzip, '-f', patch_file], stdout=PIPE, stderr=PIPE)
 
       (output, error) = process.communicate('')
 
@@ -379,14 +390,14 @@ class PatchGz(Patch):
                           patch_file, error))
          sys.exit(1)
 
-      # Get rid of the file extension
-      patch_file = patch_file.strip('.gz')
+      # Get rid of the file extension (.gz)
+      patch_file = patch_file[:len(patch_file)-3]
       Patch.__init__(self, patch_file)
 
 #~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~
 
 # The list of searched suffixes for patch names (ASCII, Bzip2, Gzip)
-patch_suffixes = ('', '.bz2', '.gz')
+patch_suffixes = ('', '.bz2_', '.gz_')
 # The corresponding classes for each patch suffix listed above IN SAME ORDER
 patch_classes = (Patch, PatchBz2, PatchGz)
 # This is the description printed with the program usage message
@@ -413,14 +424,18 @@ def download_patch(search_location, patch_number, save_loc):
          if 'timed out' in str(err):
             print >> sys.stderr, 'Timed out connecting to server'
             sys.exit(1)
-         raise err
+         continue
       # A 404 code means we didn't find it
       if url_patch.getcode() == 404:
          url_patch.close()
          continue
       # Otherwise we found it, so use urlretrieve to download the file
       url_patch.close()
-      local_patch = path.join(save_loc, fixname)
+      # Hack for compressed patch files
+      if fixname.endswith('_'):
+         local_patch = path.join(save_loc, fixname[:len(fixname)-1])
+      else:
+         local_patch = path.join(save_loc, fixname)
       print '  Downloading %s' % fixname
       urllib.urlretrieve(search_location + fixname, local_patch)
       # Now that we have the patch file saved, return the appropriate PatchClass
@@ -484,8 +499,8 @@ def describe_patch(patch, full=True, hide_prefix=True):
    if patch.author(): print '  Author:         ', patch.author()
    if patch.date(): print '  Created on:     ', patch.date()
    if patch.programs(): print '  Programs fixed: ', ', '.join(patch.programs())
-   if patch.files_edited():
-      print '  Files affected: ', ('\n%19s' % ' ').join(patch.files_edited())
+   if patch.files_edited()[0]:
+      print '  Files affected: ', ('\n%19s' % ' ').join(patch.files_edited()[0])
    if full: print '\n', patch.description()
    print ''
 
@@ -513,18 +528,32 @@ def _files_present(patch):
    return -2: Same as -1, except we also modify this program (as in 2)
    """
 
-   edfiles = patch.files_edited()
+   edfiles, newmodes = patch.files_edited()
    if not edfiles:
       print >> sys.stderr, ('Fatal Error: The patch "%s" does not edit any ' +
                             'files!') % patch.name
       sys.exit(1)
    fname = edfiles[0]
    ret_code = 1
+   newfile_count = 0
    if ('src/sander' in fname or 'src/pmemd' in fname) and not path.isdir(
             path.join(getenv('AMBERHOME'), 'src', 'pmemd', 'src')):
       ret_code = 0
    if fname == path.split(sys.argv[0])[1]:
       ret_code = 2
+   elif not path.exists(path.join(getenv('AMBERHOME'), fname)):
+      _mkdir(path.join(getenv('AMBERHOME'), path.split(fname)[0]))
+      print 'Creating file %s' % (path.join(getenv('AMBERHOME'), fname))
+      tmpfile = open(path.join(getenv('AMBERHOME'), fname), 'w')
+      tmpfile.close()
+      try:
+         print 'Changing mode to %s' % (newmodes[0])
+         # chmod takes octal numbers, so convert the octal number
+         chmod(path.join(getenv('AMBERHOME'), fname), int(newmodes[0], 8))
+         newfile_count += 1
+      except IndexError:
+         # If our patch didn't have mode info, don't pitch a fit
+         pass
    for i in range(1,len(edfiles)):
       fname = edfiles[i]
       # If ret_code is already 1, then our first file matched one we had,
@@ -544,6 +573,15 @@ def _files_present(patch):
          print 'Creating file %s' % (path.join(getenv('AMBERHOME'), fname))
          tmpfile = open(path.join(getenv('AMBERHOME'), fname), 'w')
          tmpfile.close()
+         try:
+            print 'Changing mode to %s' % (newmodes[newfile_count])
+            # chmod takes octal numbers, so convert the octal number
+            chmod(path.join(getenv('AMBERHOME'), fname),
+                  int(newmodes[newfile_count], 8))
+            newfile_count += 1
+         except IndexError:
+            # Don't pitch a fit if our patch file didn't have permission info
+            pass
 
    return ret_code
 
@@ -775,7 +813,7 @@ if __name__ == '__main__':
          sys.exit(1)
       if opt.apply_patch: single_patch = Patch(opt.apply_patch)
       else: single_patch = Patch(opt.reverse_patch)
-      if not single_patch.files_edited():
+      if not single_patch.files_edited()[0]:
          print >> sys.stderr, 'Fatal Error: Bad patch. Could not find the ' + \
                'files that were supposed to be edited!'
       # Print out message based on whether we're applying forward or reverse
