!! top of mscale

! set our bynum selections up first
set nbynum = {{ bynum_list|length }}
{% for item in bynum_list %} blankme
set bynuma{{ forloop.counter }} = {{ item.numa }}
set bynumb{{ forloop.counter }} = {{ item.numb }}
{% endfor %} blankme

! then our regions
set nregion = {{ nregion }}
{% for item in region_list %} blankme
set regid{{ forloop.counter }} = {{ item }}
{% endfor %} blankme

! finally our link atoms
set nlink = {{ linkat_list|length }}
{% for item in linkat_list %} blankme
set segq{{ forloop.counter }} = {{ item.segq }}
set resq{{ forloop.counter }} = {{ item.resq }}
set atypq{{ forloop.counter }} = {{ item.atypq }}
set segm{{ forloop.counter }} = {{ item.segm }}
set resm{{ forloop.counter }} = {{ item.resm }}
set atypm{{ forloop.counter }} = {{ item.atypm }}
{% endfor %} blankme

calc toplayer = @nregion

write psf card name {{psf_path}}layer@{toplayer}.psf
* top layer includes everything but no link atoms
*

write coor card name {{psf_path}}layer@{toplayer}.crd
* top layer includes everything but no link atoms
*

! and begin
stream {{data_home}}/renumber.str

! make sure mass of carbons is set correctly 
! addl qqh removes the mass of the hydrogen link atom then adds it back in
! but since we're in a different script from the main, CHARMM doesn't know about it
scalar mass set 12.01100 sele ( .bonded. type qqh* ) .and. ( type C* ) show end  

{%comment%}Here we print out the whole system (with linkatoms) and let the subsystems figure out the rest.{%endcomment%}
write psf card name {{psf_path}}system_with_linkatoms.psf
* PSF for whole system (incl. linkatoms)
*
                  
write coor card name {{psf_path}}system_with_linkatoms.crd
* CRD for whole system (incl. linkatoms)
*


! We are now going to write out PSF and coordinates for each "layer" of the system. Unfortunately, this
! means completely clobbering our own PSF and coordinates, so it's a good thing that we wrote them out
! above and can just read them back in at the end.

bomlev -2 ! BAD! Needed to get around definition and lonepair deletion warnings

{%comment%}
We need to load in the whole structure, then delete atoms on a per-region basis.
e.g. in a 3-layer system, where r1 is high, r2 is med, r3 is all:
write PSF for r3 (no change)
delete .not. (r1 .or. r2)
write PSF for r2
delete .not. (r1)
write PSF for r1.

This is repeated for as many layers as we want.
{%endcomment%}

calc region = @nregion - 1 ! we already wrote out the top layer

label loop
delete atom sele .not. reg@region end {%comment%} We only delete not in a certain region, since it automatically contains the region below it. {%endcomment%}

write psf card name {{psf_path}}layer@{region}.psf
write coor card name {{psf_path}}layer@{region}.crd

incr region by -1

if @region .gt. 0 then stream regdef@{region}.str
if @region .gt. 0 then goto loop

bomlev 0 ! back to normal bomlev

delete atom sele all end
read psf card name {{psf_path}}system_with_linkatoms.psf
read coor card name {{psf_path}}system_with_linkatoms.crd
                  
mscale nsubs {{num_subsystems}} {%comment%}django does not support math in the templates, so pass this in as a var{%endcomment%}

{% for sub in subsystems %} blankme
  {%comment%} django does not support numeric forloops, so make something up for subsystems. Maybe make subsystems a list that we iterate and template from?{%endcomment%} blankme
  subs {{sub.name}} coef {{sub.coef}} prog "{{mscale_path}}" -
  outp "{{sub.out_file}}" inpu "{{sub.inp_file}}" -
  sele {{sub.selection_string}} end
{%endfor%} blankme

{%comment%} blankme
   Define subsystems in mscale.py. Pass to this script. Execute.
   mscale.py should be in either CHARMMing root or in /charmming/etc/
{%endcomment%} blankme
   sysd
end
                  
skip all
prnlev 5 node 0

!! bottom of mscale
